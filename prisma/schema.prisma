generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(uuid())
  username        String    @unique
  email           String    @unique
  firstName       String    @map("first_name")
  lastName        String    @map("last_name")
  passwordHash    String    @map("password_hash")
  profileImage    String?   @map("profile_image")
  backgroundImage String?   @map("background_image")
  bio             String?   @db.Text
  invitationCode  String?   @map("invitation_code")
  createdAt       DateTime  @default(now()) @map("created_at")
  
  favorites     UserFavorite[]
  matchesAsUser1 Match[]  @relation("User1Matches")
  matchesAsUser2 Match[]  @relation("User2Matches")
  notifications Notification[]
  sentMessages  Message[]
  friendRequestsSent Friendship[] @relation("RequestsSent")
  friendRequestsReceived Friendship[] @relation("RequestsReceived")

  @@map("users")
}

model Movie {
  id            Int       @id
  tmdbId        Int       @unique @map("tmdb_id")
  title         String
  description   String?   @db.Text
  posterPath    String?   @map("poster_path")
  backdropPath  String?   @map("backdrop_path")
  releaseDate   DateTime? @map("release_date")
  rating        Float?
  genres        Json?
  runtime       Int?
  
  favorites     UserFavorite[]
  watched       WatchedMovie[]
  
  @@map("movies")
}

model UserFavorite {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  movieId   Int      @map("movie_id")
  addedAt   DateTime @default(now()) @map("added_at")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  movie     Movie    @relation(fields: [movieId], references: [id], onDelete: Cascade)
  
  @@unique([userId, movieId])
  @@map("user_favorites")
}

model Match {
  id          String       @id @default(uuid())
  user1Id     String       @map("user1_id")
  user2Id     String       @map("user2_id")
  status      MatchStatus  @default(PENDING)
  createdAt   DateTime     @default(now()) @map("created_at")
  acceptedAt  DateTime?    @map("accepted_at")
  backgroundImage String?  @map("background_image")
  
  user1       User         @relation("User1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2       User         @relation("User2Matches", fields: [user2Id], references: [id], onDelete: Cascade)
  watched     WatchedMovie[]
  notes       MatchNote[]
  messages    Message[]
  
  @@unique([user1Id, user2Id])
  @@map("matches")
}

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model WatchedMovie {
  id         String    @id @default(uuid())
  matchId    String    @map("match_id")
  movieId    Int       @map("movie_id")
  watchedAt  DateTime  @default(now()) @map("watched_at")
  rating     Int?
  
  match      Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  movie      Movie     @relation(fields: [movieId], references: [id], onDelete: Cascade)
  
  @@unique([matchId, movieId])
  @@map("watched_movies")
}

model MatchNote {
  id        String   @id @default(uuid())
  matchId   String   @map("match_id")
  movieId   Int      @map("movie_id")
  note      String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  
  @@map("match_notes")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  data      Json?
  createdAt DateTime         @default(now()) @map("created_at")
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notifications")
}

enum NotificationType {
  MATCH_REQUEST
  MATCH_ACCEPTED
  MOVIE_WATCHED
  FRIEND_REQUEST
  FRIEND_ACCEPTED
}

enum FriendStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model Friendship {
  id          String       @id @default(uuid())
  requesterId String       @map("requester_id")
  addresseeId String       @map("addressee_id")
  status      FriendStatus @default(PENDING)
  createdAt   DateTime     @default(now()) @map("created_at")
  acceptedAt  DateTime?    @map("accepted_at")

  requester   User         @relation("RequestsSent", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee   User         @relation("RequestsReceived", fields: [addresseeId], references: [id], onDelete: Cascade)
  messages    Message[]

  @@unique([requesterId, addresseeId])
  @@map("friendships")
}

model Message {
  id        String    @id @default(uuid())
  matchId   String?   @map("match_id")
  friendId  String?   @map("friend_id")
  senderId  String    @map("sender_id")
  content   String    @db.Text
  createdAt DateTime  @default(now()) @map("created_at")
  expiresAt DateTime  @map("expires_at")

  match     Match?    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  friendship Friendship? @relation(fields: [friendId], references: [id], onDelete: Cascade)
  sender    User      @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
  @@index([matchId])
  @@index([friendId])
  @@index([expiresAt])
}
